name: Petpal CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  # Job 1: Build y Tests Unitarios/Integración Locales con MySQL en el Runner
  build-and-test-local:
    runs-on: ubuntu-latest
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: testdb
        ports: ["3306:3306"]
        options: >-
          --health-cmd="mysqladmin ping -h localhost -proot"
          --health-interval=10s
          --health-retries=3
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - name: Install dependencies
        run: npm install --no-bin-links

      - name: Make Jest executable
        run: chmod +x ./node_modules/.bin/jest

      - name: Wait for MySQL
        run: |
          for i in {1..20}; do # Aumentamos el tiempo de espera por si acaso
            mysqladmin ping -h127.0.0.1 -uroot -proot && break
            sleep 2
          done

      - name: Create .env for local tests
        run: |
          cat > .env <<EOF
          DB_HOST=127.0.0.1
          DB_USER=root
          DB_PASSWORD=root
          DB_DATABASE=testdb
          DB_PORT=3306
          JWT_SECRET=testing-secret
          EOF

      - name: Load database schema for tests (Using the proven schema)
        run: mysql -h127.0.0.1 -uroot -proot testdb < ./scripts/schema-ci-testdb.sql # Crea este archivo!

      - name: Run Unit Tests
        run: npm run test:unit -- --testResultsProcessor="jest-junit" --outputFile="junit.xml" # Ajusta el comando para generar JUnit XML
        continue-on-error: false # ¡Importante! Si fallan, el job falla aquí.

      - name: Publish Unit Test Results
        uses: dorny/test-reporter@v1
        if: always() # Siempre publica los resultados, incluso si el paso anterior falla
        with:
          name: Unit Tests Report
          path: junit.xml # Ruta a tu reporte JUnit XML
          reporter: jest-junit # O el formato que uses

      - name: Run Integration Tests (Local)
        run: npm run test:integration -- --testResultsProcessor="jest-junit" --outputFile="junit-integration.xml" # Ajusta el comando
        continue-on-error: false # ¡Importante! Si fallan, el job falla aquí.

      - name: Publish Integration Test Results (Local)
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Local Integration Tests Report
          path: junit-integration.xml
          reporter: jest-junit

  # Job 2: Deploy a QA y Pruebas de Integración Remotas
  deploy-to-qa-and-test:
    needs: build-and-test-local # Solo si el build y tests locales son exitosos
    runs-on: ubuntu-latest
    environment: # Define un entorno 'qa' (opcional, pero buena práctica)
      name: qa
      url: https://petpal-backend-qa.up.railway.app # URL de tu backend de QA (aproximada, se puede obtener dinámicamente)
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install Railway CLI
        run: npm install -g @railway/cli

      - name: Login to Railway
        run: railway login --token ${{ secrets.RAILWAY_TOKEN }}
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }} # Asegúrate de que este Secret existe en GitHub

      - name: Deploy to QA
        run: railway up --environment qa --service petpal-backend # Asegúrate que 'petpal-backend' es el nombre de tu servicio en Railway QA
        # Railway automáticamente usará las variables de entorno que ya configuraste para la DB de QA en este servicio

      - name: Get QA Deployment URL
        id: get_qa_url
        run: |
          # Asegúrate que 'petpal-backend' es el nombre de tu servicio de backend en Railway QA
          QA_URL=$(railway status --json | jq -r '.deployments[] | select(.serviceName == "petpal-backend" and .environmentName == "qa") | .publicUrl')
          echo "QA_URL=${QA_URL}" >> "$GITHUB_OUTPUT"
        
      - name: Wait for QA Deployment to be ready
        run: |
          # Pequeña espera para que el servicio recién desplegado esté accesible
          sleep 10
          # Puedes agregar un curl o lógica para esperar un 200 OK de tu API de salud
          curl -f -I "${{ steps.get_qa_url.outputs.QA_URL }}/health" || true # Ajusta /health a tu endpoint de salud

      - name: Run Remote Integration Tests on QA
        run: npm run test:integration-remote -- --testResultsProcessor="jest-junit" --outputFile="junit-integration-remote.xml" # Un nuevo script para tests de integración remotos
        env:
          BASE_URL: ${{ steps.get_qa_url.outputs.QA_URL }} # Pasa la URL de QA a tus tests
          NODE_ENV: integration-remote
        continue-on-error: false # El job falla si los tests remotos fallan

      - name: Publish Remote Integration Test Results
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Remote Integration Tests Report (QA)
          path: junit-integration-remote.xml
          reporter: jest-junit

  # Job 3: Aprobación Manual y Deploy a Producción
  deploy-to-prod:
    needs: deploy-to-qa-and-test # Solo si el despliegue a QA y sus tests son exitosos
    runs-on: ubuntu-latest
    environment: # Configura el entorno 'production' con aprobación manual
      name: production
      url: https://petpal-backend-production.up.railway.app # URL de tu backend de PROD
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install Railway CLI
        run: npm install -g @railway/cli

      - name: Login to Railway
        run: railway login --token ${{ secrets.RAILWAY_TOKEN }}
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}

      - name: Deploy to Production
        # Este comando dispara el deploy en Railway para el entorno 'production'
        # Railway detecta el push o el comando 'railway up' y gestiona el despliegue.
        run: railway up --environment production --service petpal-backend # Asegúrate que 'petpal-backend' es el nombre de tu servicio de Producción

      # Nota: No necesitamos el 'manual-approval' aquí si ya configuraste la aprobación en GitHub Environments.
      # La aprobación ya se maneja directamente por la configuración del 'environment: production' de GitHub Actions.